template<typename T>
class PersistentSegmentTree {
    vector<T> arr; //copy of the array to build SegmentTree
    static const int MAX_VERSION = 1000; //maximum number of versions

    struct node {
        node *pl = NULL, *pr = NULL;
        int l, r, mid;
        T value = 0; //Sum segTree
        node(int _l, int _r) {l = _l; r = _r; mid = (l+r)>>1;}
        node(int _l, int _r, T _value) {l = _l; r = _r; value = _value; mid = (l+r)>>1;}
        void update() { //Sum segTree
            value = 0;
            if(pl) value += pl->value;
            if(pr) value += pr->value;
        }
    };
    node *root[MAX_VERSION]; //it stores the i versions after updates

    void build(node *n) { //O(n)
        if(n->l == n->r) {n->value = arr[n->l]; return;}
        n->pl = new node(n->l, n->mid);
        n->pr = new node(n->mid+1, n->r);
        build(n->pl);
        build(n->pr);
        n->update();
    }
    node* update(node *n, int q, ll x) { //O(logn)
        if(n->l == n->r) {
            return new node(n->l, n->r, x);
        }
        node *nod = new node(n->l, n->r);
        if(q <= n->mid) {
            nod->pl = update(n->pl, q, x);
            nod->pr = n->pr;
        } else {
            nod->pl = n->pl;
            nod->pr = update(n->pr, q, x);
        }
        nod->update();
        return nod;
    }
    T query(node *n, int l, int r) { //O(logn)
        if(l <= n->l && n->r <= r) return n->value;
        if(r < n->l || n->r < l) return 0; //Sum segTree
        return query(n->pl, l, r) + query(n->pr, l, r);
    }
    public:
    PersistentSegmentTree(){} //Void build
    PersistentSegmentTree(int n){ //Build from empty vector of size n
        arr.assign(n, 0);
        root[0] = new node(0, n-1);
        build(root[0]);
    }
    PersistentSegmentTree(vector<T> &v) { //Build from vector v
        arr = v;
        root[0] = new node(0, (int)arr.size() - 1);
        build(root[0]);
    }
    T query(int version, int l, int r) {return query(root[version], l, r);} //O(logn)
    void update(int version, int new_version, int idx, T x) { //update the segTree version into new_version root
        root[new_version] = update(root[version], idx, x); //O(logn)
    }
};

template<typename T>
class NumberDistinctNumbers { //Works for queries online. For offline can check MO's
    static const int MAX_VECTOR_NUMBER = 1000; //the max element possible in the input array
    PersistentSegmentTree<T> pst;

    public:
    NumberDistinctNumbers(vector<T> &v) { //O(nlogn)
        T last[MAX_VECTOR_NUMBER]; //last ocurrence of the i-number in the array, updating from left to right
        int n = v.size();
        fill(last, last+MAX_VECTOR_NUMBER, -1);
        pst = PersistentSegmentTree<T>(n);
        for(int r = 0; r < n; r++) {
            pst.update(max(0, r-1), r, r, 1); //Actualize r
            if(last[v[r]] != -1) pst.update(max(0, r-1), r, last[v[r]], 0); //Remove last[v[r]]
            last[v[r]] = r; //Actualize last[v[r]]
        }
    }
    T query(int l, int r) { //Return the number of Distinct numbers in [l..r], O(logn)
        return pst.query(r, l, r);
    }
};
