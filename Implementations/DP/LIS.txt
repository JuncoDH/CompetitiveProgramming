//O(n log n) Longest Increasing Subsequence (strictly)
int LIS_len(vi &v) {
    int i, n = v.size(), it;
    vi LIS;
    LIS.pb(v[0]);

    for(i = 1; i < n; ++i) {
        if(binary_search(LIS.begin(), LIS.end(), v[i])) continue;
        else if(v[i] > LIS.back()) LIS.pb(v[i]);
        else {
            it = upper_bound(LIS.begin(), LIS.end(), v[i]) - LIS.begin();
            LIS[it] = v[i];
        }
    }
    return (int)LIS.size();
}

//returns a vector with LIS
vi LIS_v(vi &v) {
    int i, n = v.size(), it, lis_len = 0;
    vi LIS, ans, lis_time(n); //keep the assigned possition when was added to the LIS vector 
    LIS.pb(v[0]);
    lis_time[0] = ++lis_len;

    for(i = 1; i < n; ++i) {
        it = lower_bound(LIS.begin(), LIS.begin() + lis_len, v[i]) - LIS.begin();
        
        if(v[i] > LIS.back()) {LIS.pb(v[i]); lis_time[i] = ++lis_len;}
        else if(LIS[it] == v[i]) {lis_time[i] = it + 1; continue;}
        else {
            //it = upper_bound(LIS.begin(), LIS.end(), v[i]) - LIS.begin();
            LIS[it] = v[i];
            lis_time[i] = it + 1;
        }
    }

    //here lis_len is equal to LIS_len()
    //we can retrieve all LIS_v going from right to left substracting 1 to the current lis_len
    for(i = n - 1; i >= 0; --i) if(lis_time[i] == lis_len) {ans.pb(v[i]); --lis_len;}
    reverse(ans.begin(), ans.end());
    return ans;
}