//////now 0-1 knap problem, pareja[nvalue] = (cost, benefit)
    
    int S[nvalue][B + 1];
    
    for(j = 0; j <= B; ++j){
        if(j - pareja[0].fi >= 0) S[0][j] = pareja[0].se;
        else S[0][j] = 0;
    }
    
    for(i = 1; i < nvalue; ++i){
        for(j = 0; j <= B; ++j){
            if(j - pareja[i].fi >= 0){
                S[i][j] = max(S[i - 1][j], S[i - 1][j - pareja[i].fi] + pareja[i].se);
            }
            else S[i][j] = S[i - 1][j];
        }
    }
    
    //get the left-most equal number
   for(i = B - 1; i >= 0; --i) if(S[nvalue - 1][i] != S[nvalue - 1][B]) break;
    
    cout << S[nvalue - 1][B] << "\n" << i + 1 << "\n";