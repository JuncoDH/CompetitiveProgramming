//Tarjan algorithm use 1 DFS while this use 2 (x2 slower)
//shows in O(n) SCC Strongly Connected Components. 
//first dfs1 when node is processed is added to the stack, then the graph is transposed, then dfs2 when node is processed is showed in its component 
vector<vi> graph, graphRev;
stack<int> s;
vector<bool> visited;
ll n;

void dfs1(ll u){
    visited[u] = true;
    for(auto v : graph[u]){
        if(visited[v] == false) dfs1(v);
    }
    s.push(u);
}

void dfs2(ll u){
    visited[u] = true;
    for(auto v : graphRev[u]){
        if(visited[v] == false) dfs2(v);
    }
    cout << u << ".";
}

void Kosaraju(){
    ll i, j;
    
    //transpose graph to graphRev
    for(i = 0; i < n; ++i){
        for(j = 0; j < sz(graph[i]); ++j){
            graphRev[graph[i][j]].pb(i);
        }
    }
    
    visited.assign(n, false);
    dfs1(0);
    visited.assign(n, false);
    

    while(true) {
        while(s.empty() == false && visited[s.top()] == true) s.pop();
        if(s.empty() == true) break;

        dfs2(s.top());
        cout << endl;
        
    }
     
}

void example(){
    n = 5;
    graph.assign(5, vi());
    graphRev.assign(5, vi());
    graph[0].pb(2);
    graph[0].pb(3);
    graph[1].pb(0);
    graph[2].pb(1);
    graph[3].pb(4);
    Kosaraju();
}