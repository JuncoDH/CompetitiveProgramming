//Aho-Corasick : Source https://cp-algorithms.com/string/aho_corasick.html
//Construct a trie with the words to search and then follow letter by letter the text to search, following suffix links if the character is not found
const int alpha_size = 26;
struct node{
    vi edge;                                //edge[c] : next transition of vertex using char c
    int leaf = 0;                           //number of words ending at current vetex
    int link = -1;                          //id of suffix link
    vi go;                                  //go[c] : the next vertex to go
    int p = -1;                             //id of the parent 
    char pch = '$';                         //t[parent of current vertex].edge[pch] = current vertex
    int count = -1;                         //count of matches (+leaf for every vertex followed by suffix link
    node(int p = -1, char pch = '$') : p(p), pch(pch){
        edge.assign(alpha_size, -1);
        go.assign(alpha_size, -1);
    }
};
vector<node> t(1);
int sz = 1;

void add_string(string w) {
    int p = 0;
    char c;
    for(char ch : w) {
        c = ch - 'a';
        if(t[p].edge[c] == -1) {
            t.pb(node(p, ch));
            t[p].edge[c] = sz++;
        }
        p = t[p].edge[c];
    }
    t[p].leaf++;
}

int go(int v, char c);

int get_link(int v) {
    if(t[v].link == -1) {
        if(v == 0 || t[v].p == 0) t[v].link = 0;
        else t[v].link = go(get_link(t[v].p), t[v].pch);
    }
    return t[v].link;
}

int go(int v, char ch) {
    char c = ch - 'a';
    if(t[v].go[c] == -1) {
        if(t[v].edge[c] == -1) t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);
        else t[v].go[c] = t[v].edge[c];
    }
    return t[v].go[c];
}

int count(int v) {
    if(t[v].count == -1) {
        if(v == 0) t[v].count = 0;
        else t[v].count = t[v].leaf + count(get_link(v));
    }
    return t[v].count;
}
