                                //Source : https://cp-algorithms.com/string/suffix-automaton.html
                                //DAWG : Directed Acyclic Word Graph
vi len;                         //len[i] : the length of the longest substring in the i-th class 
vi link;                        //link[i] : the parent of i
vector<map<char, int> > edges;  //edges[i] : the connections from node i
int sz;                         //sz : number of classes
int last;                       // last : id of the equivalence class of the whole string

//O(s.length)
void suffix_automaton(string s) {
    int i, n = s.length(), cur, p, q, clone;
    //state t0, empty
    sz = 1;
    last = 0;
    len.pb(0);
    link.pb(-1);
    edges.pb(map<char, int>());
    
    for(i = 0; i < n; ++i) {
        cur = sz++;
        len.pb(len[last] + 1);
        link.pb(0);
        edges.pb(map<char, int>());
        
        //while doesn't exist edge add it
        for(p = last; p != -1 && edges[p].find(s[i]) == edges[p].end(); p = link[p]) {
            edges[p][s[i]] = cur;
        }
        
        if(p != -1) {
            q = edges[p][s[i]];
            if(len[p] + 1 == len[q]) { // in cur you have [len[q] + 1 ... len[cur]], so link[cur] = q
                link[cur] = q;
            }
            else{ //else create new equivalence class, (clone q)
                clone = sz++;
                len.pb(len[p] + 1);
                link.pb(link[q]);
                edges.pb(edges[q]);
                for(; p != -1 && edges[p][s[i]] == q; p = link[p]) {
                    edges[p][s[i]] = clone;
                }
                
                link[cur] = link[q] = clone;
            }
            
            
            
        }
        last = cur;
    }
}

vi terminal; //all nodes that are terminal nodes. If a substring w ends in a terminal node, w is suffix of s 
bool set_terminal = false;
//O(s.length)
void fill_terminal() {
    //for(int p = last; p > -1; p = link[p]) terminal.pb(p); //compressed form
    if(set_terminal) return;
    set_terminal = true;
    terminal.assign(sz, 0);
    for(int p = last; p > 0; p = link[p]) terminal[p] = 1;
}

//O(w.length), also the last i is the longest prefix of w that is on s
bool is_substring(string w) {
    int p = 0, i, n = w.length();
    for(i = 0; i < n; ++i) {
        if(edges[p].find(w[i]) == edges[p].end()) return false;
        p = edges[p][w[i]];
    }
    return true;
}

//O(w.length)
bool is_suffix(string w){
    int p = 0, i, n = w.length();
    
    fill_terminal();
    
    for(i = 0; i < n; ++i) {
        if(edges[p].find(w[i]) == edges[p].end()) return false;
        p = edges[p][w[i]];
    }
    if(binary_search(terminal.begin(), terminal.end(), p)) return true;
    return false;
}

vi dp_path; //number of substrings = number of paths in a DAG, solvable with top-down dp

ll number_substrings_rec(ll id) {
    if(dp_path[id] != -1) return dp_path[id];
    ll sum = 0;
    for(auto u : edges[id]) {
        sum += number_substrings_rec(u.se);
    }
    return dp_path[id] = sum + 1;
}

//O(s.length)
ll number_substrings() {
    dp_path.assign(sz, -1);
    return number_substrings_rec(0) - 1;
}

//total length of all substrings: ans[v] = sum(dp_path[w] + ans[w])) because every word w is 1 unit length more starting from v

//lexicography k-th substring = k-th path

//number of ocurrences of w = number of paths from the equivalence class of w to a terminal state
//O(s.length) the first time to fill the dp table and O(w.length) the next times
vi terminal_path;
bool set_terminal_path = false;

ll fill_terminal_path_rec(int id) {
    if(terminal_path[id]) return terminal_path[id];
    ll suma = terminal[id];//0 if not else 1
    for(auto u : edges[id]) {
        suma += fill_terminal_path_rec(u.se);
    }
    return terminal_path[id] = suma;
}

void fill_terminal_path(){
    if(set_terminal_path) return;
    set_terminal_path = true;
    fill_terminal();
    terminal_path.assign(sz, 0);
    fill_terminal_path_rec(0);
}


ll number_ocurrences(string w) {
    int p = 0, i, n = w.length();
    fill_terminal_path();
    for(i = 0; i < n; ++i) {
        if(edges[p].find(w[i]) == edges[p].end()) return 0;
        p = edges[p][w[i]];
    }
    return terminal_path[p];
}