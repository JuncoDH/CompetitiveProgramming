vll v; 
ll n;

typedef pll node;

vector<node> tree;
vll lazy;

///////////////////////////////////////////
//Modify this functions. Actualy is a (min, min_pos) with range sum update
void merge_node(int k) {
    if(tree[k<<1].fi < tree[k<<1|1].fi) tree[k] = tree[k<<1];
    else tree[k] = tree[k<<1|1];
}

void update_node(int k, ll val) {
    tree[k].fi += val;
    lazy[k] += val;
}

void lazy_update(int k, int l, int r) {
    if(l != r) {tree[k<<1].fi += lazy[k]; lazy[k<<1] += lazy[k];}
    if(l != r) {tree[k<<1|1].fi += lazy[k]; lazy[k<<1|1] += lazy[k];}
    lazy[k] = 0;
}

node node_cmp(node a, node b) {
    if(a.fi < b.fi) return a;
    return b;
}
//////////////////////////////////////////////////

void show() {
    int i, j, heigh = 0, space = 12, penality = 4;
    cout << "-------------------" << endl;
    for(i = 1; i <= 9; ++i) {
        for(j = 0; j < space - penality * heigh; ++j) cout << " ";
        cout << i << ":" << tree[i];
        if(i + 1 == LSB(i + 1)) {cout << endl; ++heigh;}
    }
    cout << endl << "-------------------" << endl;
}

void build(int k, int l, int r) {
    if(l == r) {tree[k] = mp(v[l], l); return;} //Create node
    int mid = (l + r) >> 1;
    build(k<<1, l, mid);
    build(k<<1|1, mid + 1, r);
    merge_node(k);
}

void build() {build(1, 0, n - 1);}

void update(int k, int l, int r, int ql, int qr, ll val) {
    lazy_update(k, l, r);
    if(ql <= l && r <= qr) {update_node(k, val); return;}
    if(qr < l || r < ql) return;
    int mid = (l + r) >> 1;
    update(k<<1, l, mid, ql, qr, val);
    update(k<<1|1, mid + 1, r, ql, qr, val);
    merge_node(k);
}

void update(int l, int r, ll val) {update(1, 0, n - 1, l, r, val);}

node query(int k, int l, int r, int ql, int qr) {
    lazy_update(k, l, r);
    if(ql <= l && r <= qr) return tree[k];
    if(qr < l || r < ql) return mp(LLONG_MAX, LLONG_MAX); //return dummie node
    int mid = (l + r) >> 1;
    node a = query(k<<1, l, mid, ql, qr);
    node b =query(k<<1|1, mid + 1, r, ql, qr);
    if(qr <= mid) return a;
    if(mid < ql) return b;
    return node_cmp(a, b);
}
ll query() {return tree[1].se;}