//Data structure for queries: 1 - add interval [l, r], 2 - remove interval [l, r], 3 - Overlaps [l, r] with the added intervals? With which one?
//Interval tree, save the intervals in an AVL tree as [Low, High] with max_heigh = maximum heigh for all nodes in the tree rooted at him 
//for search operation if the current node overlaps, return it. Else if n->left->max_heigh > low search at left, else search at right
struct node{
    int low, heigh; //[Low, Heigh], can also be double
    int max_heigh; //max_heigh = max heigh for all nodes in its subtree
    node* left = NULL;
    node* right = NULL;
    int height = 1;
    node(int l, int h) : low(l), heigh(h), max_heigh(h) {}
};

int height(node* n) {
    if(n == NULL) return 0;
    return n->height;
}

int max_heigh(node* n) {
    if(n == NULL) return -1;
    return n->max_heigh;
}

void update_height(node* n){
    n->height = max(height(n->left), height(n->right)) + 1;
    n->max_heigh = max(max_heigh(n), max(max_heigh(n->left), max_heigh(n->right)));
}

int get_balance(node* n) {
    if(n == NULL) return 0;
    return height(n->right) - height(n->left);
}

//returns new root
node* right_rotate(node* y) {
    node *x = y->left;
    y->left = x->right;
    x->right = y;
    update_height(y);
    update_height(x);
    return x;
}

node* left_rotate(node* y) {
    node *x = y->right;
    y->right = x->left;
    x->left = y;
    update_height(y);
    update_height(x);
    return x;
}


node* balance_AVL(node *n) {
    update_height(n);
    
    int balance = get_balance(n), balancel = get_balance(n->left), balancer = get_balance(n->right);

    //4 rotation cases:
    if(balance < -1 && balancel <= 0) { //Left-Left rotation
        return right_rotate(n);
    }
    else if(balance < -1) { //Left-Right rotation
        n->left = left_rotate(n->left);
        return right_rotate(n);
    }
    else if(balance > 1 && balancer >= 0) { //Right-Right rotation
        return left_rotate(n);
    }
    else if(balance > 1) { //Right-Left rotation
        n->right = right_rotate(n->right);
        return left_rotate(n);
    }
    
    //Not need to rotate
    return n;
}

//root = insert(root, key);
node* insert_AVL(node *n, int low, int heigh) {
    if(n == NULL) return new node(low, heigh);

    //Standard BST insertion
    if(low < n->low) n->left = insert_AVL(n->left, low, heigh);
    else if(low > n->low) n->right = insert_AVL(n->right, low, heigh);
    else { //equal low, compare heigh
        if(heigh < n->heigh) n->left = insert_AVL(n->left, low, heigh);
        else if(heigh > n->heigh) n->right = insert_AVL(n->right, low, heigh);
        else return n; //equal interval, not allowed
    }

    return balance_AVL(n);
}

//root = delete_AVL(root, key);
node* delete_AVL(node* n, int low, int heigh) {
    if(n == NULL) return n;
    
    //Standard BST deletion
    if(low < n->low) n->left = delete_AVL(n->left, low, heigh);
    else if(low > n->low) n->right = delete_AVL(n->right, low, heigh);
    else { 
        if(heigh < n->heigh) n->left = insert_AVL(n->left, low, heigh);
        else if(heigh > n->heigh) n->right = insert_AVL(n->right, low, heigh);
        else{
            //node to delete found
            if(n->left == NULL || n->right == NULL) {
                node* temp = n->left ? n->left : n->right;
                n = temp;
                //case removed last node
                if(n == NULL) return n;
            } 
            else {
                node* temp = n->right;
                while(temp->right) temp = temp->right;
                n->low = temp->low;
                n->heigh = temp->heigh;
                n->right = delete_AVL(n->right, n->low, n->heigh);
            }
        }
    }
    
    return balance_AVL(n);
}

pii search_Interval(node*n, int low, int heigh) {
    if(n == NULL) return mp(-1, -1);
    if((heigh < n->low || n->heigh < low) == false) return mp(n->low, n->heigh);
    if(max_heigh(n->left) >= heigh) return search_Interval(n->left, low, heigh);
    return search_Interval(n->right, low, heigh);
}

void show(node *n) { //preOrder
    if(n == NULL) return;
    cout << "("<<n->low << " " << n->heigh << " " << n->max_heigh<<")"<< " ";
    show(n->left);
    show(n->right);
}

void example() { //for texting, 1 x = insert(x); 2 x = delete(x); rand(), l, r search(l, r);
    int l, r, ex;
    pii ans
    node* root = NULL;

   while(true) {
        cin >> ex >> l >> r;
        if(ex == 1) root = insert_AVL(root, l, r);
        else if(ex == 2) root = delete_AVL(root, l, r);
        else cout << (ans = search_Interval(root, l, r))<<endl;
        show(root);
        cout << endl;
    }
}