const int int_inf = INT_MAX / 10;
vector<vi> cost;
int n;
//Hungarian algorithm, also Maximum weighted complete bipartite matching.
//We convert the minimum assignment to maximum bipartite weighted matching. cost[n][n] = -cost[n][n]
//For every iteration, or we find an augmenting path or we increase the size (+ edges) of the equality graph
int hungarian() {
    //preprocess, converts from minimum weighted matching to maximum weighted matching, w(e) = max(w(i)) - w(e)
    for(auto &row : cost)
        for(auto &el : row)
            el *= -1;
    int x, y, xx, yy, root, delta;
    vi xy(n, -1), yx(n, -1), lx(n), ly(n, 0), augmenting(n);//augmenting[y] is the father of y in the alternating tree
    vb S(n);
    vector<pii> slack(n); //slack.se = slackx 
    for(x = 0; x < n; ++x) 
        lx[x] = *max_element(cost[x].begin(), cost[x].end());
    for(root = 0; root < n; ++root) {
        fill(augmenting.begin(), augmenting.end(), -1);
        fill(S.begin(), S.end(), false);
        S[root] = true;
        for(y = 0; y < n; ++y)
            slack[y] = mp(lx[root] + ly[y] - cost[root][y], root);
        
        while(true) {
            //relabel if delta > 0
            delta = int_inf; 
            for(yy = 0; yy < n; ++yy) {
                if(augmenting[yy] == -1 && slack[yy].fi < delta) {
                    delta = slack[yy].fi;
                    x = slack[yy].se;
                    y = yy;
                }
            }
            if(delta > 0) {
                //this relabeling will remain feasible
                for(xx = 0; xx < n; ++xx) {
                    if(S[xx]) lx[xx] -= delta;
                }
                for(yy = 0; yy < n; ++yy) {
                    if(augmenting[yy] != -1) ly[yy] += delta;
                    else slack[yy].fi -= delta;
                }
            }
            augmenting[y] = x;
            x = yx[y];
            if(x == -1) break; //y is free, augmenting path found
            S[x] = true; //add edge to the alternating tree
            for(y = 0; y < n; ++y) {
                if(lx[x] + ly[y] - cost[x][y] < slack[y].fi) {
                    slack[y] = mp(lx[x] + ly[y] - cost[x][y], x);
                }
            }
        }
        //++matching, there is an augmenting path
        while(y != -1) {
            x = augmenting[y];
            yy = xy[x];
            xy[x] = y;
            yx[y] = x;
            y = yy;
        }
    }
    return -(accumulate(lx.begin(), lx.end(), 0) + accumulate(ly.begin(), ly.end(), 0));
}