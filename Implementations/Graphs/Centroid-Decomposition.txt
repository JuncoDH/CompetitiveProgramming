//-------------------------------- CD: Centroid Decomposition ---------------------------------------------------------------------------------
//the centroid of a tree is a node whose removal partitions the tree into components each one with size at most n/2
//1- the centroid tree contains all n nodes 
//2- the heigh of the centroid tree is at most log(n)
//3- given two nodes A and B and C = lca(A, B) in the centroid tree, the path A -> B in the original tree can be broken in the path A -> C -> B
//4- We only need to keep nlogn paths, for every node to it ancestors in the centroid tree. You can find lca by moving up from the deeper node
vi centroid_tree[MAX_N];
int subtree_sz[MAX_N];
//improvement: remove the edges in set<int> graph[n] and don't need to have bool[] is_centroid
bool is_centroid[MAX_N];


void insert(int u, int v) {
    graph[u].pb(v);
    graph[v].pb(u);
}
int centroid_parent[MAX_N]; //tree that leaf nodes point to their ancestor
void fill_centroid_parent() {
    for(int i = 0; i < MAX_N; ++i) centroid_parent[i] = i;
}
void centroid_insert(int u, int v) {
    centroid_parent[v] = u;
    //centroid_tree[u].pb(v);
    //centroid_tree[v].pb(u);
}

//fills the size of each node in the subtree delimited by previous centroids
void dfs_sz(int u, int p) {
    subtree_sz[u] = 1;
    for(auto v : graph[u]) {
        if(v == p || is_centroid[v]) continue;
        dfs_sz(v, u);
        subtree_sz[u] += subtree_sz[v];
    }
}

int find_centroid(int u, int p, int sz) {
    for(auto v : graph[u]) {
        if(v == p || is_centroid[v]) continue;
        if(subtree_sz[v] > sz / 2) return find_centroid(v, u, sz);
    }
    return u;
}

//returns the root of the decomposed tree
int fill_centroid_tree(int u) {
    dfs_sz(u, -1);
    u = find_centroid(u, -1, subtree_sz[u]);
    is_centroid[u] = true;
    //echo(u); //next node to be inserted in the centroid tree
    for(auto v : graph[u]) {
        if(is_centroid[v]) continue;
        centroid_insert(u, fill_centroid_tree(v));
    }
    return u;
} 