//AP[i] = true iff i is an articuation point, one vertex such as removing it the number of the graph's components increase
//vertex u is one AP if u is the root of DFS and it has 2 childs or if it has one children v such that low[v] >= discovery[u]
//low[v] is the minimum discovery time that there is a back edge from the sub-tree of v 
vector<vi> graph;
vi low, discovery, parent, AP;//Articulation Points
int Time = 0;

void add(int i, int j){
    //undirected graph
    graph[i].pb(j);
    graph[j].pb(i);
}

void dfs(int u){
    low[u] = discovery[u] = Time + 1;
    ++Time;
    int childs = 0;
    for(auto it : graph[u]){
        if(discovery[it] == -1){
            ++childs;
            parent[it] = u;
            dfs(it);
            if(parent[u] == -1 && childs > 1) AP[u] = true;//root case
            if(parent[u] != -1 && low[it] >= discovery[u]) AP[u] = true;//no back edges
            low[u] = min(low[u], low[it]);
        }
        else{
            if(parent[u] != it) low[u] = min(low[u], discovery[it]);// it's a back edge
        }
    }
}

void ini(int n){
    graph.assign(n, vi());
    AP.assign(n, false);
    discovery.assign(n, -1);
    low.assign(n, -1);
    parent.assign(n, -1);
}