// TODO Gaussian elimination.
// TODO Determinant.
// TODO Inverse Matrix.

const int MOD = 1e5; // MOD of the Matrix, remove this if MOD is not used.

template<typename T>
class Matrix {
    public:
    int nrow = 0;
    int ncol = 0;
    vector<vector<T>> v;
    Matrix() {}
    // Empty Matrix.
    Matrix(int _nrow, int _ncol) {
        nrow = _nrow;
        ncol = _ncol;
        v.assign(nrow, vector<T>(ncol, 0));
    }
    // Example: Matrix<ll> a({{1, 2}, {3, 4}}); // Can't use for one columnd vector.
    Matrix(vector<vector<T>> _v) {
        nrow = _v.size();
        ncol = _v[0].size();
        v = _v;
    }
    friend ostream& operator << (ostream &os, Matrix<T> m) {
        int i, j;
        for(i = 0; i < m.nrow; i++) {
            for(j = 0; j < m.ncol; j++) {
                if(j) cout << " ";
                cout << m.v[i][j];
            }
            cout << "\n";
        }
        return os;
    }
    Matrix<T> operator + (const Matrix<T> other) {
        int i, j;
        for(i = 0; i < nrow; i++) {
            for(j = 0; j < ncol; j++) {
                v[i][j] += other[i][j];
                v[i][j] %= MOD;
            }
        }
        return *this;
    }
    // Use this for an empty square Matrix to create an identity Matrix.
    Matrix<T> convert_to_identity() {
        for(int i = 0; i < nrow; i++) v[i][i] = 1;
        return *this;
    }
    Matrix<T> operator * (const Matrix<T> other) {
        int i, j, k;
        Matrix<T> ans(nrow, other.ncol);
        for(i = 0; i < nrow; i++) {
            for(j = 0; j < other.ncol; j++) {
                for(k = 0; k < ncol; k++) {
                    ans.v[i][j] += v[i][k]*other.v[k][j];
                    ans.v[i][j] %= MOD;
                }
            }
        }
        return ans;
    }
    Matrix<T> operator ^ (int ex) {
        if(ex == 0) {
            Matrix<T> ans(nrow, ncol);
            return ans.convert_to_identity();
        }
        Matrix<T> half = (*this) ^ (ex/2);
        if(ex%2) return half * half * (*this);
        else return half * half;
    }
};
