//The rank is the index of the vector in a sorted set of all permutations of this vector.
//You can calculate the rank by fixing elements in [0, i] and calculating combinatorics
//For calculating the vector is the inverse, calculate the elements fixing the first i. 
//Next pick one of the rest and see wheter adding him pass the remaining rank. If true, add the previous one
//Both of this functions work with repeated elements in O(n^2)
vll fact(21);
void fill_fact(){ll i; fact[0] = 1; for(i = 1; i < 21; ++i) fact[i] = fact[i - 1] * i;}

//returns the rank given the permutation
ll v_to_rank(vll per){
    ll i, n = per.size(), _rank = 1, comb;
    map<ll, ll> m; //(number, nº of times rep)
    for(ll el : per) m[el]++;

    //fixing the first i
    for(i = 0; i < n; ++i){
        comb = fact[n - i - 1];
        for(auto rest : m)
            comb /= fact[rest.se]; //repetitions
        
        for(auto smaller : m) {
            if(smaller.fi >= per[i]) break;
            _rank += comb * smaller.se;
        }
        
        if(m[per[i]] > 1)m[per[i]]--;
        else m.erase(per[i]);
    }
    
    return _rank;
}

//returns the vector given the rank and the alphabet
vll rank_to_v(ll _rank, vll alpha) {
    ll n = alpha.size(), i, comb, sum;
    pll last;
    vll ans;
    map<ll, ll> m;
    
    for(auto el : alpha) m[el]++;
    
    //First i selected
    for(i = 0; i < n; ++i) {
        comb = fact[n - i - 1];
        for(auto ele : m)
            comb /= fact[ele.se]; //repetitions
            
        last = mp(-1ll, -1ll);    
        sum = 0;
        
        for(auto ele : m) {
            if(last == mp(-1ll, -1ll)) {last = ele; continue;}
            if(sum + comb * last.se >= _rank) break;
            sum += comb * last.se;
            last = ele;
        } 

        _rank -= sum;
        ans.pb(last.fi);
        if(m[last.fi] > 1) m[last.fi]--;
        else m.erase(last.fi);
    }

    return ans;
}




/*
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//THIS NOT SUPPORT REPEATED ELEMENTS NEITHER IS TESTED

vi per = {2, 4, 1, 3};
vll fact(21);

void fill_fact(){ll i; fact[0] = 1; for(i = 1; i < 21; ++i) fact[i] = fact[i - 1] * i;}

//O(n^2), optimizable via preprocess
ll permutation_to_rank(){
    ll ans = 1, n = per.size(), i, j, smaller;
    for(i = 0; i < n; ++i){
        smaller = 0;
        for(j = i + 1; j < n; ++j) smaller += per[j] < per[i]; //count smaller elements at the right of fixed per[0, i]
        ans += smaller * fact[n - i - 1]; //combinatory, divide by the factorial of the repetitions of the letters
    }
    return ans;
}

//O(n^2), optimizable via preprocess
vll rank_to_permutation(ll _rank, vi possibles){
    ll n = possibles.size(), i;
    vll permutation;
    _rank--;
    sort(possibles.begin(), possibles.end());
    for(i = 0; i < n; ++i){
        permutation.pb(possibles[_rank / fact[n - i - 1]]);
        possibles.erase(possibles.begin() + _rank / fact[n - i - 1]);
        _rank -= fact[n - i - 1] * (_rank / fact[n - i - 1]);
    }
    return permutation;    
}
*/