typedef complex<ld> cd;
typedef vector<cd> vcd;

void show(vcd v) {
    int cont = 0;
    cout << "------------------" << endl;
    for(auto el : v) cout << el.real() << "x^" << cont++ << " + ";
    cout << endl << "------------------" << endl;
} 

//Evaluate the pol a in the n roots of the unity, in O(n log n)
vcd fft(vcd a) {
    int n = a.size(), i;
    if(n == 1) return a;
    
    //the first n-th root of unity
    cd w_n(cos((2 * PI) / n), sin((2 * PI) / n));
    cd w(1.0, 0.0);
    
    //Divide
    vcd a_even, a_odd;
    for(i = 0; i < n; ++i) {
        if(i % 2) a_odd.pb(a[i]);
        else a_even.pb(a[i]);
    }
    
    vcd y_even = fft(a_even);
    vcd y_odd = fft(a_odd);
    vcd y(n);
    for(i = 0; i < n/2; ++i) {
        y[i] = y_even[i] + w * y_odd[i];
        y[i + n/2] = y_even[i] - w * y_odd[i];
        w *= w_n;
    }
    
    return y;
}

//O(n) multiplication point by point
vcd multiply(vcd a, vcd b) {
    int n = a.size(), i;
    vcd c(n);
    for(i = 0; i < n; ++i) c[i] = a[i] * b[i];
    return c;
}

//conjugate the points instead of the root and resize the polynomio by a factor of 1/n
vcd inverse(vcd a) {
    int n = a.size(), i;
    for(i = 0; i < n; ++i) a[i] = conj(a[i]);
    a = fft(a);
    for(i = 0; i < n; ++i) a[i] /= n;
    return a;
}

void example_fft() {
    //vcd a = {1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0}, b = {5.0, 6.0, 7.0, 8.0, 0.0, 0.0, 0.0, 0.0}, c;
    vcd a = {1.0, 0.0, 1.0, 0.0}, b = {1.0, 1.0, 0.0, 0.0}, c;
    a = fft(a);
    b = fft(b);
    c = multiply(a, b);

    c = inverse(c);
    show(c);
}