////////////////////////////////////////////
/////INICIO FFT
typedef complex<double> cd;
#define PI acos(-1)
//Funciones que incorpora
void show(vector<cd> x);
void fft(vector<cd>& a);
vector<cd> inverse_fft(vector<cd> &x);
vector<cd> multiplicar (vector<cd> a, vector<cd> b);

//Muestra el polinomio
void show(vector<cd> x){
	ll n = x.size();
	for(int i= 0; i < n; ++i){
		if(i>0)cout<<" + ";
		cout<<(ll)x[i].real()<<"x^"<<i;//TRUNCA
	}
	cout<<endl<<"---------------------------"<<endl;
}

//Hace el FFT, evalua en el polinomio en las n-th raices de uno (convolucion). O(nlogn)
void fft(vector<cd>& a){
	ll n = a.size(), i;
	
	//Caso base
	if(n <= 1)return;
	
	//a0 terminos pares, a1 terminos impares
	vector<cd> a0, a1;
	
	for(i=0; i < n; ++i){
		if((i & 1) == 0)a0.pb(a[i]);
		else a1.pb(a[i]);
	}
	
	//LLama de forma recursiva
	fft(a0);
	fft(a1);

	//Une en O(n) los terminos pares e impares
	for(i = 0; i < n/2 ; ++i){
		cd w = polar(1.0, (2*PI*i)/n);
		a[i] = a0[i] + w*a1[i];
		a[i + n/2] = a0[i] - w*a1[i];
		
	}
	
}

//Es la inversa del FFT, calcula los coeficientes del polinomio sabiendo n puntos. LLama a FFT. O(nlogn)
vector<cd> inverse_fft(vector<cd> &x){
	ll n = x.size(), i;
	
	//Hace el conjugado de los puntos
	for(i = 0; i < n; ++i)x[i]=conj(x[i]);
	
	//Llama a FFT (deconvolucion)
	fft(x);
	
	//Redimensiona el polinomio dividiendolo para n, su tamanio
	for(i = 0; i < n; ++i)x[i]/=n;
	
	return x;
}

//Coge dos vectores de puntos y devuelve otro vector de puntos. O(n)
vector<cd> multiplicar (vector<cd> a, vector<cd> b){
	ll i, n = a.size();
	vector<cd> c(n);

	//Multiplica punto a punto O(n)
	for(i = 0; i < n; ++i)c[i]=a[i]*b[i];

	return c;
}

void ejemploFFT(){
	//Multiplica dos polinomios de igual tamanio. tiene que tener tamanio potencia de dos, y la mitad tienen que ser ceros
	//Pues el grado de c es el doble y necesita el doble de puntos para quedar determinado.
	vector<cd> a = {1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0}, b = {5.0, 6.0, 7.0, 8.0, 0.0, 0.0, 0.0, 0.0}, c;
	fft(a);
	fft(b);
	c = multiplicar(a, b);
	inverse_fft(c);
	
	cout<<"RESULTADO"<<endl;
	show(c);
}
/////FIN FFT
////////////////////////////////////////////