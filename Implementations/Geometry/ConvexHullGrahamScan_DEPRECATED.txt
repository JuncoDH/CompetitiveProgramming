typedef pair<ll, ll> point;
#define x first
#define y second

DA RE, DONT USE THIS, USE INSTEAD CP ALGORITHM IMPLEMENTATION

//3D vectorial product of P2P1 and P3P2.
//return 0 if they are colinear, 1 if they are counterclockwise (left-turn) and -1 if they are clockwise (right-turn)
const int LEFT = 1;
const int RIGHT = -1;
int orientation(point p1, point p2, point p3){
    ll ans = (p2.x - p1.x) * (p3.y - p2.y) - (p3.x - p2.x) * (p2.y - p1.y);
    if(ans == 0) return ans;
    return ans > 0 ? LEFT : RIGHT;
}


point firstPoint;

bool compare(point a, point b){
    if(a == firstPoint) return true;
    if(b == firstPoint) return false;
    int o = orientation(firstPoint, a, b);
    if(o == 0) return a.x < b.x;
    return o == LEFT? true : false;
}

//supposse n > 2
ll szHull;
vector<point> Hull;
//Graham Scan, O(nlogn)
void convexHull(vector<point> &vpoint, int n){
    int i, o;
    firstPoint = vpoint[0];
    for(i = 1; i < n; ++i) ckmin(firstPoint, vpoint[i]);

    sort(vpoint.begin(), vpoint.end(), compare);
  
    if(n <= 2) {cout << "0"; exit(0);}
    
    Hull = {vpoint[0], vpoint[1]};
    szHull = 2;
    
    for(i = 2; i < n; ++i){
        o = orientation(Hull[szHull - 2], Hull[szHull - 1], vpoint[i]);
        while(o == RIGHT || o == 0) {
            Hull.pop_back();
            --szHull;
            if(szHull < 2) break;
            o = orientation(Hull[szHull - 2], Hull[szHull - 1], vpoint[i]);
        }
        Hull.pb(vpoint[i]);
        ++szHull;
    }

}
